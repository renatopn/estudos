<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Captain America English Games üõ°Ô∏è</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='90' font-size='90'>üõ°Ô∏è</text></svg>">
    
    <style>
        /* --- CSS GERAL --- */
        body {
            font-family: 'Arial', sans-serif;
            background-color: #212121;
            color: #f5f5f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        header {
            background-color: #003366;
            color: #ffffff;
            padding: 15px 30px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            border: 3px solid #ff0000;
            width: 90%;
            max-width: 700px;
            text-align: center;
        }

        .navbar {
            background-color: #333;
            width: 100%;
            max-width: 700px;
            display: flex;
            justify-content: space-around;
            padding: 10px 0;
            border-radius: 5px;
            margin-bottom: 20px;
            border-bottom: 2px solid #0099ff;
        }

        .nav-btn {
            background: none;
            color: #f5f5f5;
            border: none;
            padding: 8px 15px;
            cursor: pointer;
            font-size: 1em;
            transition: color 0.2s, background-color 0.2s;
        }

        .nav-btn:hover, .nav-btn.active {
            background-color: #0099ff;
            color: #fff;
            border-radius: 3px;
        }

        .game-container {
            width: 90%;
            max-width: 700px;
            background-color: #333333;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
            border: 5px solid #ff0000;
        }

        .screen {
            display: none;
            text-align: center;
        }

        .screen.active {
            display: block;
        }

        /* Estilos de Bot√£o Comum */
        button:not(.nav-btn, .cell) {
            background-color: #ff0000;
            color: white;
            padding: 10px 20px;
            border: 2px solid #ffffff;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.1em;
            margin-top: 15px;
            transition: background-color 0.2s, transform 0.1s;
        }

        button:not(.nav-btn, .cell):hover {
            background-color: #cc0000;
            transform: scale(1.05);
        }
        
        /* --- ESTILOS DO QUIZ --- */
        .stats {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #003366;
            border-radius: 8px;
            color: #ffffff;
        }

        #quiz-icon {
            font-size: 4em;
            margin-bottom: 15px;
        }

        .options-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }

        .option-btn {
            background-color: #444444;
            color: white;
            padding: 15px;
            border: 2px solid #f5f5f5;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s, border-color 0.2s;
        }

        .option-btn.correct { background-color: #00cc00; border-color: #ffffff; }
        .option-btn.incorrect { background-color: #cc0000; border-color: #ffffff; }
        .feedback-message { margin-top: 15px; font-weight: bold; min-height: 20px; }
        #timer { font-weight: bold; color: #0099ff; }

        /* --- ESTILOS DO MEMORY GAME (JOGO DA MEM√ìRIA) --- */
        .memory-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin: 20px auto;
        }

        .memory-card {
            background-color: #003366;
            color: white;
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2em;
            cursor: pointer;
            border-radius: 8px;
            border: 3px solid #ff0000;
            perspective: 1000px;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }

        .memory-card.flipped { transform: rotateY(180deg); }
        .card-content { position: absolute; backface-visibility: hidden; }
        .card-back { font-size: 2em; line-height: 1; }
        .card-front { transform: rotateY(180deg); }
        .memory-card.matched { border-color: #00cc00; pointer-events: none; opacity: 1; }

        /* --- ESTILOS DO WORD SEARCH (CA√áA-PALAVRAS) --- */
        .word-search-grid {
            display: grid;
            margin: 20px auto;
            border: 3px solid #0099ff;
            border-radius: 5px;
        }

        .cell {
            width: 35px;
            height: 35px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.1em;
            font-weight: bold;
            border: 1px solid #444;
            cursor: pointer;
            background-color: #444;
            user-select: none; /* Desabilita sele√ß√£o de texto nativa */
            -webkit-user-select: none;
            -moz-user-select: none;
        }
        
        .cell.highlighted {
            background-color: #ff0000; /* Destaque ao arrastar */
            color: white;
        }

        .cell.found {
            background-color: #00cc00 !important; /* Verde para palavras encontradas */
            color: white;
            font-style: italic;
        }

        #word-list {
            list-style: none;
            padding: 0;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }

        #word-list li {
            background-color: #003366;
            padding: 5px 10px;
            margin: 5px;
            border-radius: 5px;
            transition: background-color 0.3s;
        }

        #word-list li.found-word {
            background-color: #00cc00;
            text-decoration: line-through;
            color: #212121;
        }
    </style>
</head>
<body>

    <header>
        <h1>Captain America English Games üá∫üá∏</h1>
    </header>

    <div class="navbar">
        <button id="nav-quiz" class="nav-btn active">Quiz üìù</button>
        <button id="nav-memory" class="nav-btn">Memory Game üß†</button>
        <button id="nav-wordsearch" class="nav-btn">Word Search üîç</button>
    </div>

    <div class="game-container">
        
        <div id="quiz-screen" class="screen active">
            <h2>The Challenge Quiz üéØ</h2>
            <div class="stats">
                <span>Score: <span id="quiz-score">0</span></span>
                <span>Question: <span id="quiz-count">0</span>/10</span>
                <span id="timer">‚è≥ 7s</span>
            </div>
            <h3 id="quiz-icon"></h3>
            <div id="quiz-text-context"></div>
            <p id="quiz-question-text"></p>
            <div id="quiz-options" class="options-grid"></div>
            <p id="quiz-feedback" class="feedback-message"></p>
            <button id="start-quiz-btn">Start 10 Questions üöÄ</button>
        </div>

        <div id="memory-game-screen" class="screen">
            <h2>Memory Training üß†</h2>
            <p id="memory-current-set" style="color: #0099ff;">Set 1: Body Parts</p>
            <p style="color: #00cc00; font-size: 0.9em;">*Dica: As cartas corretas permanecem abertas para confer√™ncia.*</p>
            <div id="memory-board" class="memory-grid"></div>
            <p id="memory-feedback" class="feedback-message"></p>
            <button id="memory-set-btn" data-set="1">Next Set (Set 2) ‚û°Ô∏è</button>
        </div>
        
        <div id="word-search-screen" class="screen">
            <h2>Word Search Puzzle üîç</h2>
            <div id="word-search-grid" class="word-search-grid"></div>
            <p style="margin-top: 15px;">**Find these words:**</p>
            <ul id="word-list"></ul>
            <p id="search-feedback" class="feedback-message"></p>
            <button id="start-search-btn">Start Word Search üß©</button>
            <button id="next-search-btn" style="display: none;">Next Puzzle ‚û°Ô∏è</button>
        </div>
        
        <div id="end-screen" class="screen" style="display: none;">
            <h2>Mission Complete! ‚≠ê</h2>
            <p id="final-message">You are a Hero!</p>
            <button onclick="window.location.reload()">Back to Menu</button>
        </div>

    </div>

    <script>
        // --- JAVASCRIPT (L√≥gica do Jogo) ---

        // --- DADOS DO JOGO ---

        // Vocabul√°rio Completo com √çcones (usado no Quiz e Ca√ßa-Palavras)
        const fullVocabulary = {
            'ear': 'üëÇ', 'head': 'üë§', 'neck': 'üëî', 'arm': 'üí™', 'hand': 'üñêÔ∏è', 'leg': 'ü¶µ', 'feet': 'ü¶∂', 'foot': 'üë£',
            'hair': 'üíá', 'eye': 'üëÅÔ∏è', 'nose': 'üëÉ', 'mouth': 'üëÑ', 'body': 'üßç', 'run': 'üèÉ', 'walk': 'üö∂', 'clap': 'üëè',
            'sing': 'üé§', 'jump': '‚¨ÜÔ∏è', 'short': 'üîΩ', 'big': 'üêò', 'small': 'üêú', 'strong': 'üèãÔ∏è', 'long': 'üìè', 'tall': 'ü¶í',
            'banana': 'üçå', 'apple': 'üçé', 'chicken': 'üçó', 'cheese pizza': 'üçï', 'lemonade': 'üçã', 'milk': 'ü•õ', 'water': 'üíß',
            'orange juice': 'üçä', 'tea': '‚òï', 'drink': 'ü•§', 'eat': 'üçΩÔ∏è', 'cookie': 'üç™', 'fish': 'üêü', 'egg': 'ü•ö', 'orange': 'üü†',
            'rice': 'üçö', 'salad': 'ü•ó', 'sandwich': 'ü•™', 'soup': 'ü•£', 'juice': 'üßÉ', 'fruit': 'üçá', 'grapes': 'üçá',
            'grandmother': 'üëµ', 'grandfather': 'üë¥', 'boy': 'üë¶', 'girl': 'üëß', 'rabbit': 'üêá', 'cat': 'üêà', 'cow': 'üêÑ',
            'dog': 'üêï', 'donkey': 'üê¥', 'duck': 'ü¶Ü', 'frog': 'üê∏', 'horse': 'üêé', 'goat': 'üêê', 'sheep': 'üêë', 'turtle': 'üê¢',
            'pets': 'üêæ', 'bird': 'üê¶', 'kitten': 'üê±', 'puppy': 'üê∂', 'chick': 'üê•', 'bunny': 'üê∞', 'lamb': 'üêë', 'calf': 'üêÑ',
            'elephant': 'üêò', 'hopping': 'üê∏', 'climbing': 'üßó', 'running': 'üèÉ', 'eating': 'üçΩÔ∏è', 'playing': '‚öΩ', 'singing': 'üé§',
            'talking': 'üó£Ô∏è', 'doing': 'üõ†Ô∏è', 'crawling': 'üë∂', 'swimming': 'üèä', 'flying': '‚úàÔ∏è', 'jumping': 'ü§∏'
        };

        // --- QUIZ DATA (Perguntas de Vocabul√°rio e Gram√°tica abrangentes) ---

        // 1. VOCABUL√ÅRIO (Uma pergunta para cada item principal do vocabul√°rio)
        const vocabQuestions = Object.keys(fullVocabulary).map(word => {
            const icon = fullVocabulary[word];
            // Gera 3 op√ß√µes incorretas aleat√≥rias
            const allWords = Object.keys(fullVocabulary).filter(w => w !== word);
            const incorrectOptions = shuffleArray(allWords).slice(0, 3);
            return {
                type: 'vocab',
                icon: icon,
                question: `What is the English word for this: ${icon}?`,
                correct: word,
                options: [...incorrectOptions, word]
            };
        });
        
        // 2. GRAM√ÅTICA (Uma pergunta para cada estrutura gramatical solicitada)
        const grammarQuestions = [
            // is / are
            { type: 'gram', question: "My dog **___** small. My cats **___** strong. (is / are)", correct: 'is', options: ['is', 'are', 'am', 'can'], context: "Choose the verb for the first sentence ('My dog')." },
            // a / an
            { type: 'gram', question: "I see **___** boy and **___** elephant. (a / an)", correct: 'a', options: ['a', 'an', 'the', 'is'], context: "Choose the article for the first word 'boy'." },
            // his / her / your
            { type: 'gram', question: "**___** name is John. **___** name is Mary. (His / Her)", correct: 'His', options: ['His', 'Her', 'Your', 'They'], context: "Choose the possessive for a boy (John)." },
            // can / can't
            { type: 'gram', question: "Can a horse **run**? Yes, it **___**.", correct: "can", options: ["can", "can't", "is", "are"], context: "Choose the correct short answer." },
            // has / have
            { type: 'gram', question: "I **___** a big nose. She **___** long hair. (have / has)", correct: 'have', options: ['have', 'has', 'is', 'are'], context: "Choose the verb for the first sentence ('I')." },
            // My/Your/His/Her is/are
            { type: 'gram', question: "Complete: **His** **legs** **are** **___**.", correct: 'long', options: ['long', 'run', 'apple', 'mouth'], context: "His legs are (adjective)." },
            // What is this? / It's your...
            { type: 'gram', question: "Answer the question: What is this? (Referring to the ear icon: üëÇ)", correct: "It's your ear.", options: ["It's your ear.", "Yes, it is.", "He is eating.", "No, it isn't."], context: "The object is an ear." },
            // What are they doing?
            { type: 'gram', question: "The children are **jumping**. Answer the question: What are they doing?", correct: "They are jumping.", options: ["They are jumping.", "He is jumping.", "It is jumping.", "I am jumping."], context: "Refer to 'they' and the action 'jumping'." },
            // Do you want...? / Yes, please.
            { type: 'gram', question: "Do you want some lemonade? Give a positive answer.", correct: "Yes, please.", options: ["No, thank you.", "Yes, please.", "No, he doesn't.", "Yes, I do."], context: "Use the politeness phrases." },
            // What's your favorite...?
            { type: 'gram', question: "What's your favorite animal? Choose a response.", correct: "I like dogs.", options: ["I like dogs.", "It's a dog.", "Yes, I do.", "He likes dogs."], context: "The structure I like..." },
            // What is he/she eating?
            { type: 'gram', question: "John is eating a sandwich. What is he eating?", correct: "He is eating a sandwich.", options: ["He is eating a sandwich.", "I am eating a sandwich.", "She is eating a sandwich.", "Yes, he is."], context: "Use the structure He is eating..." },
            // Contractions (can't, don't, what's)
            { type: 'gram', question: "The dog **can not** climb. Choose the contraction.", correct: "can't", options: ["can't", "don't", "what's", "doesn't"], context: "Choose the contraction for 'can not'." }
        ];

        // Combina e embaralha todas as perguntas
        const allQuizQuestions = shuffleArray([...vocabQuestions, ...grammarQuestions]);

        // --- MEMORY GAME DATA (3 Sets) ---
        const memorySets = [
            { name: "Set 1: Body Parts", pairs: [
                { icon: 'üëÇ', word: 'ear' }, { icon: 'üñêÔ∏è', word: 'hand' }, { icon: 'üë§', word: 'head' }, { icon: 'ü¶µ', word: 'leg' },
                { icon: 'üëÅÔ∏è', word: 'eye' }, { icon: 'üëÉ', word: 'nose' }, { icon: 'üëÑ', word: 'mouth' }, { icon: 'üíá', word: 'hair' }
            ]},
            { name: "Set 2: Food & Drinks", pairs: [
                { icon: 'üçå', word: 'banana' }, { icon: 'üçé', word: 'apple' }, { icon: 'üçï', word: 'pizza' }, { icon: 'ü•õ', word: 'milk' },
                { icon: 'üíß', word: 'water' }, { icon: '‚òï', word: 'tea' }, { icon: 'ü•™', word: 'sandwich' }, { icon: 'ü•ó', word: 'salad' }
            ]},
            { name: "Set 3: Animals & Actions", pairs: [
                { icon: 'üêá', word: 'rabbit' }, { icon: 'üêà', word: 'cat' }, { icon: 'üèÉ', word: 'running' }, { icon: 'üé§', word: 'singing' },
                { icon: 'üê¢', word: 'turtle' }, { icon: 'üêò', word: 'elephant' }, { icon: 'üèä', word: 'swimming' }, { icon: 'üßó', word: 'climbing' }
            ]}
        ];

        // --- WORD SEARCH DATA ---
        // Palavras para ca√ßa-palavras (apenas aquelas com 3 letras ou mais)
        const searchableWords = Object.keys(fullVocabulary).filter(w => w.length >= 3 && w.length <= 8);
        const MAX_GRID_SIZE = 12; 
        const WORDS_PER_ROUND = 5;

        // --- VARI√ÅVEIS DE ESTADO ---
        let currentQuizIndex = 0;
        let quizScore = 0;
        let questionsQuizAsked = 0;
        let quizTimer;
        let isTimerRunning = false;
        let currentMemorySetIndex = 0;
        
        // Word Search State
        let currentWordSearchWords = [];
        let foundWords = [];
        let wordSearchGrid = [];
        let isDragging = false;
        let startCell = null;
        let highlightedCells = [];

        // --- ELEMENTOS HTML ---
        const navBtns = {
            quiz: document.getElementById('nav-quiz'),
            memory: document.getElementById('nav-memory'),
            wordsearch: document.getElementById('nav-wordsearch')
        };
        const screens = {
            quiz: document.getElementById('quiz-screen'),
            memory: document.getElementById('memory-game-screen'),
            wordsearch: document.getElementById('word-search-screen'),
            end: document.getElementById('end-screen')
        };
        const quizIcon = document.getElementById('quiz-icon');
        const quizTextContext = document.getElementById('quiz-text-context');
        const quizQuestionText = document.getElementById('quiz-question-text');
        const quizOptionsDiv = document.getElementById('quiz-options');
        const quizFeedback = document.getElementById('quiz-feedback');
        const quizScoreSpan = document.getElementById('quiz-score');
        const timerSpan = document.getElementById('timer');
        const quizCountSpan = document.getElementById('quiz-count');
        const startQuizBtn = document.getElementById('start-quiz-btn');
        const memoryBoard = document.getElementById('memory-board');
        const memoryFeedback = document.getElementById('memory-feedback');
        const memorySetBtn = document.getElementById('memory-set-btn');
        const memoryCurrentSetSpan = document.getElementById('memory-current-set');
        const wordSearchGridDiv = document.getElementById('word-search-grid');
        const wordListUl = document.getElementById('word-list');
        const searchFeedback = document.getElementById('search-feedback');
        const startSearchBtn = document.getElementById('start-search-btn');
        const nextSearchBtn = document.getElementById('next-search-btn');

        // --- FUN√á√ïES DE L√ìGICA GERAL ---

        function showScreen(id) {
            Object.values(screens).forEach(screen => screen.classList.remove('active'));
            document.getElementById(id).classList.add('active');
            
            Object.values(navBtns).forEach(btn => btn.classList.remove('active'));
            if (id.includes('quiz')) navBtns.quiz.classList.add('active');
            else if (id.includes('memory')) navBtns.memory.classList.add('active');
            else if (id.includes('search')) navBtns.wordsearch.classList.add('active');
            else if (id.includes('end')) navBtns.quiz.classList.add('active'); 
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // --- L√ìGICA DO QUIZ ---

        function startQuiz() {
            quizScore = 0;
            questionsQuizAsked = 0;
            currentQuizIndex = 0;
            quizScoreSpan.textContent = quizScore;
            quizCountSpan.textContent = `${questionsQuizAsked}/10`;
            startQuizBtn.style.display = 'none';
            loadNextQuizQuestion();
        }

        function loadNextQuizQuestion() {
            clearInterval(quizTimer);
            quizFeedback.textContent = '';
            timerSpan.textContent = '‚è≥ 7s';
            quizOptionsDiv.innerHTML = '';
            quizIcon.textContent = '';
            quizTextContext.innerHTML = '';
            
            if (questionsQuizAsked >= 10) {
                showScreen('end-screen');
                document.getElementById('final-message').textContent = `Mission Complete! Your final score is ${quizScore}/10! ‚≠ê`;
                startQuizBtn.style.display = 'block'; // Mostra bot√£o para reiniciar ao voltar
                return;
            }

            const q = allQuizQuestions[currentQuizIndex];
            quizCountSpan.textContent = `${questionsQuizAsked + 1}/10`;
            
            if (q.type === 'vocab') {
                quizIcon.textContent = q.icon;
                quizQuestionText.textContent = q.question;
            } else {
                // Gram√°tica
                quizIcon.textContent = 'üìù';
                quizQuestionText.textContent = q.question;
                if (q.context) {
                     quizTextContext.innerHTML = `<blockquote style="color:#0099ff; border-left: 3px solid #ff0000; padding-left: 10px;">Tip: ${q.context}</blockquote>`;
                }
            }
            
            // Garantir que o √≠ndice avance para a pr√≥xima pergunta
            currentQuizIndex = (currentQuizIndex + 1) % allQuizQuestions.length;
            
            const shuffledOptions = shuffleArray([...q.options]);

            shuffledOptions.forEach(option => {
                const button = document.createElement('button');
                button.classList.add('option-btn');
                button.textContent = option.charAt(0).toUpperCase() + option.slice(1);
                button.onclick = () => checkQuizAnswer(button, option, q.correct);
                quizOptionsDiv.appendChild(button);
            });

            startQuizTimer();
        }

        function startQuizTimer() {
            let timeLeft = 7;
            timerSpan.textContent = `‚è≥ ${timeLeft}s`;
            isTimerRunning = true;

            quizTimer = setInterval(() => {
                timeLeft--;
                timerSpan.textContent = `‚è≥ ${timeLeft}s`;

                if (timeLeft <= 0) {
                    clearInterval(quizTimer);
                    isTimerRunning = false;
                    quizFeedback.textContent = "Time's up! ‚è±Ô∏è Keep going!";
                    questionsQuizAsked++;
                    setTimeout(loadNextQuizQuestion, 1500);
                }
            }, 1000);
        }

        function checkQuizAnswer(button, selected, correct) {
            if (!isTimerRunning) return;

            clearInterval(quizTimer);
            isTimerRunning = false;
            Array.from(quizOptionsDiv.children).forEach(btn => btn.disabled = true);
            
            if (selected === correct) {
                quizScore++;
                quizScoreSpan.textContent = quizScore;
                button.classList.add('correct');
                quizFeedback.textContent = congratulatoryMessages[Math.floor(Math.random() * congratulatoryMessages.length)];
            } else {
                button.classList.add('incorrect');
                Array.from(quizOptionsDiv.children).find(btn => btn.textContent.toLowerCase() === correct.toLowerCase()).classList.add('correct');
                quizFeedback.textContent = encouragementMessages[Math.floor(Math.random() * encouragementMessages.length)];
            }

            questionsQuizAsked++;
            setTimeout(loadNextQuizQuestion, 2000);
        }

        const congratulatoryMessages = [
            'Amazing! Captain America is proud! üõ°Ô∏è', 'Great job! You got it right! üëç',
            'Perfect! You are a hero! ‚≠ê', 'Excellent! Keep going! üí™',
        ];
        const encouragementMessages = [
            'Almost! Try the next one! ü§î', 'Don‚Äôt give up! Captain America believes in you! ü´°',
            'Oops! You can do better! Keep practicing! üìù', 'Incorrect. Focus on the word! üëÄ',
        ];

        // --- L√ìGICA DO MEMORY GAME ---

        let hasFlippedCard = false;
        let lockBoard = false;
        let firstCard, secondCard;
        let matchesFound = 0;
        let totalMemoryPairs = 0;
        
        function setupMemoryGame(setIndex) {
            const currentSet = memorySets[setIndex];
            totalMemoryPairs = currentSet.pairs.length;
            matchesFound = 0;
            memoryBoard.innerHTML = '';
            memoryFeedback.textContent = '';
            memoryCurrentSetSpan.textContent = `${currentSet.name}`;

            let cards = [];
            currentSet.pairs.forEach(pair => {
                cards.push({ content: pair.icon, isIcon: true, matchId: pair.word });
                cards.push({ content: pair.word.toUpperCase(), isIcon: false, matchId: pair.word });
            });

            shuffleArray(cards);

            memoryBoard.style.gridTemplateColumns = `repeat(4, 1fr)`;

            cards.forEach(cardData => {
                const card = document.createElement('div');
                card.classList.add('memory-card');
                card.dataset.matchId = cardData.matchId;
                card.innerHTML = `
                    <div class="card-content card-back">üõ°Ô∏è</div>
                    <div class="card-content card-front">${cardData.content}</div>
                `;
                card.addEventListener('click', flipCard);
                memoryBoard.appendChild(card);
            });
            
            // Define o texto do bot√£o
            let nextSetIndex = (currentMemorySetIndex + 1) % memorySets.length;
            if (nextSetIndex === 0) {
                 memorySetBtn.textContent = 'Restart Memory Games (Set 1) üîÑ';
            } else {
                 memorySetBtn.textContent = `Next Set (Set ${nextSetIndex + 1}) ‚û°Ô∏è`;
            }
            memorySetBtn.style.display = 'none';
        }

        function flipCard() {
            if (lockBoard) return;
            if (this === firstCard) return;
            if (this.classList.contains('matched')) return; // Evita clicar em cartas j√° encontradas

            this.classList.add('flipped');

            if (!hasFlippedCard) {
                hasFlippedCard = true;
                firstCard = this;
                return;
            }

            secondCard = this;
            checkForMatch();
        }

        function checkForMatch() {
            let isMatch = firstCard.dataset.matchId === secondCard.dataset.matchId;

            if (isMatch) {
                disableCards();
            } else {
                unflipCards();
            }
        }

        function disableCards() {
            firstCard.removeEventListener('click', flipCard);
            secondCard.removeEventListener('click', flipCard);
            
            firstCard.classList.add('matched');
            secondCard.classList.add('matched');
            
            memoryFeedback.textContent = 'Match! Keep it open! ‚úÖ';

            resetBoard();
            matchesFound++;

            if (matchesFound === totalMemoryPairs) {
                memoryFeedback.textContent = 'Set Complete! All pairs found! üí•';
                memorySetBtn.style.display = 'block';
            }
        }

        function unflipCards() {
            lockBoard = true;
            memoryFeedback.textContent = 'No match! Try again.';

            setTimeout(() => {
                firstCard.classList.remove('flipped');
                secondCard.classList.remove('flipped');
                memoryFeedback.textContent = '';
                resetBoard();
            }, 1500);
        }

        function resetBoard() {
            [hasFlippedCard, lockBoard] = [false, false];
            [firstCard, secondCard] = [null, null];
        }

        function nextMemorySet() {
            currentMemorySetIndex = (currentMemorySetIndex + 1) % memorySets.length;
            setupMemoryGame(currentMemorySetIndex);
            memorySetBtn.dataset.set = currentMemorySetIndex + 1;
        }

        // --- L√ìGICA DO WORD SEARCH (CA√áA-PALAVRAS) ---

        function startWordSearch() {
            startSearchBtn.style.display = 'none';
            nextSearchBtn.style.display = 'none';
            foundWords = [];
            nextSearchRound(); // Inicia a primeira rodada
        }

        function selectRandomWords() {
            // Palavras j√° encontradas
            const alreadyFound = foundWords.map(w => w.toUpperCase());
            // Palavras restantes no vocabul√°rio que t√™m 3-8 letras e ainda n√£o foram encontradas nesta sess√£o.
            const remainingWords = searchableWords.filter(w => !alreadyFound.includes(w.toUpperCase()));
            
            if (remainingWords.length === 0) {
                searchFeedback.textContent = 'All possible words found! Restarting word list...';
                // Reinicia a lista de palavras encontradas para recome√ßar o ciclo de busca
                foundWords = []; 
                return shuffleArray(searchableWords).slice(0, WORDS_PER_ROUND);
            }
            
            return shuffleArray(remainingWords).slice(0, WORDS_PER_ROUND);
        }
        
        function generateWordSearchGrid() {
            const size = MAX_GRID_SIZE;
            wordSearchGrid = Array(size).fill(0).map(() => Array(size).fill(''));

            currentWordSearchWords.forEach(word => {
                let placed = false;
                let attempts = 0;
                const upperWord = word.toUpperCase();
                
                while (!placed && attempts < 50) {
                    attempts++;
                    const direction = Math.random() < 0.5 ? 'horizontal' : 'vertical';
                    const length = upperWord.length;

                    let startRow, startCol;
                    
                    if (direction === 'horizontal') {
                        startRow = Math.floor(Math.random() * size);
                        startCol = Math.floor(Math.random() * (size - length + 1));
                    } else { // vertical
                        startRow = Math.floor(Math.random() * (size - length + 1));
                        startCol = Math.floor(Math.random() * size);
                    }

                    // Verifica se o espa√ßo est√° livre ou cont√©m as mesmas letras
                    let canPlace = true;
                    for (let i = 0; i < length; i++) {
                        let r = startRow + (direction === 'vertical' ? i : 0);
                        let c = startCol + (direction === 'horizontal' ? i : 0);

                        if (wordSearchGrid[r][c] !== '' && wordSearchGrid[r][c] !== upperWord[i]) {
                            canPlace = false;
                            break;
                        }
                    }

                    if (canPlace) {
                        for (let i = 0; i < length; i++) {
                            let r = startRow + (direction === 'vertical' ? i : 0);
                            let c = startCol + (direction === 'horizontal' ? i : 0);
                            wordSearchGrid[r][c] = upperWord[i];
                        }
                        placed = true;
                    }
                }
            });

            // Preenche os espa√ßos vazios com letras aleat√≥rias
            const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    if (wordSearchGrid[r][c] === '') {
                        wordSearchGrid[r][c] = alphabet[Math.floor(Math.random() * alphabet.length)];
                    }
                }
            }
        }
        
        function renderWordSearch() {
            wordSearchGridDiv.innerHTML = '';
            wordSearchGridDiv.style.gridTemplateColumns = `repeat(${MAX_GRID_SIZE}, 1fr)`;
            searchFeedback.textContent = ''; // Limpa feedback

            const size = MAX_GRID_SIZE;
            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.textContent = wordSearchGrid[r][c];
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    
                    // Adiciona eventos de toque e mouse
                    cell.addEventListener('mousedown', startDrag);
                    cell.addEventListener('mousemove', drag);
                    cell.addEventListener('mouseup', endDrag);
                    cell.addEventListener('touchstart', startDrag, { passive: true });
                    cell.addEventListener('touchmove', drag, { passive: false });
                    cell.addEventListener('touchend', endDrag);

                    // Aplica a classe 'found' se a c√©lula fizer parte de uma palavra encontrada
                    if (isCellFound(r, c)) {
                         cell.classList.add('found');
                    }
                    wordSearchGridDiv.appendChild(cell);
                }
            }
            
            // Renderiza a lista de palavras
            wordListUl.innerHTML = currentWordSearchWords.map(word => 
                `<li id="word-item-${word.toUpperCase()}" class="${foundWords.includes(word.toUpperCase()) ? 'found-word' : ''}">${word.toUpperCase()}</li>`
            ).join('');
        }
        
        function isCellFound(r, c) {
            // Se a c√©lula j√° foi marcada como parte de uma palavra encontrada nesta rodada, ela deve ser renderizada como 'found'.
            // Para isso, precisar√≠amos de uma matriz de c√©lulas encontradas, mas vamos simplificar a verifica√ß√£o no DOM ap√≥s a sele√ß√£o.
            // Para rodadas futuras, a lista 'foundWords' armazena o que foi encontrado globalmente.
            
            // Simplesmente checa se a palavra j√° foi marcada como encontrada. 
            // A colora√ß√£o persistente entre rodadas √© tratada em `renderWordSearch` e `checkSelection`.
            // N√£o √© necess√°rio implementar a l√≥gica de coordenadas aqui, pois `checkSelection` aplica a classe ao DOM.
            
            return false;
        }

        // --- L√ìGICA DE DRAG AND DROP (TOUCH/MOUSE) ---
        
        function startDrag(e) {
            e.preventDefault();
            
            // Determina o elemento que iniciou o arrasto (touch ou mouse)
            let target;
            if (e.type.startsWith('touch')) {
                // Use document.elementFromPoint para touch, pois e.target pode ser um elemento intermedi√°rio
                target = document.elementFromPoint(e.touches[0].clientX, e.touches[0].clientY);
            } else {
                target = e.target;
            }

            if (target && target.classList.contains('cell') && !target.classList.contains('found')) {
                isDragging = true;
                // Limpa o destaque anterior
                highlightedCells.forEach(cell => cell.classList.remove('highlighted'));
                
                startCell = target;
                highlightedCells = [startCell];
                startCell.classList.add('highlighted');
            }
        }

        function drag(e) {
            if (!isDragging || !startCell) return;
            e.preventDefault(); 
            
            let target;
            if (e.type.startsWith('touch')) {
                const touch = e.touches[0];
                target = document.elementFromPoint(touch.clientX, touch.clientY);
            } else {
                target = e.target;
            }

            if (target && target.classList.contains('cell') && !target.classList.contains('found')) {
                const endCell = target;
                updateHighlight(startCell, endCell);
            }
        }
        
        function endDrag(e) {
            if (!isDragging || !startCell) return;
            isDragging = false;
            
            if (highlightedCells.length > 0) {
                // Monta a palavra selecionada (ordem: da c√©lula inicial para a c√©lula final)
                const selection = highlightedCells.map(cell => cell.textContent).join('');
                checkSelection(selection);
            }
            
            // Limpa o destaque, exceto se a palavra for encontrada (handled by checkSelection)
            setTimeout(() => {
                highlightedCells.forEach(cell => {
                    if (!cell.classList.contains('found')) {
                        cell.classList.remove('highlighted');
                    }
                });
                startCell = null;
                highlightedCells = [];
            }, 300);
        }

        function updateHighlight(start, end) {
            const sRow = parseInt(start.dataset.row);
            const sCol = parseInt(start.dataset.col);
            const eRow = parseInt(end.dataset.row);
            const eCol = parseInt(end.dataset.col);
            
            const newCells = [];
            
            // Horizontal ou Vertical (ignora diagonais)
            const isHorizontal = sRow === eRow;
            const isVertical = sCol === eCol;
            
            if (isHorizontal && sCol !== eCol) {
                // Ordem correta para a sele√ß√£o
                const step = sCol < eCol ? 1 : -1;
                for (let c = sCol; c !== eCol + step; c += step) {
                    newCells.push(document.querySelector(`.cell[data-row="${sRow}"][data-col="${c}"]`));
                }
            } else if (isVertical && sRow !== eRow) {
                // Ordem correta para a sele√ß√£o
                const step = sRow < eRow ? 1 : -1;
                for (let r = sRow; r !== eRow + step; r += step) {
                    newCells.push(document.querySelector(`.cell[data-row="${r}"][data-col="${sCol}"]`));
                }
            } else if (start === end) {
                // Sele√ß√£o de uma √∫nica c√©lula
                newCells.push(start);
            }
            
            // Limpa o destaque anterior e aplica o novo
            document.querySelectorAll('.cell.highlighted').forEach(cell => cell.classList.remove('highlighted'));
            newCells.forEach(cell => cell.classList.add('highlighted'));
            highlightedCells = newCells;
        }

        function checkSelection(selection) {
            if (selection.length < 3) return; // Palavras muito curtas
            
            let found = false;
            
            // Verifica a palavra normal e inversa
            const selectionUpper = selection.toUpperCase();
            const reversedSelectionUpper = selectionUpper.split('').reverse().join('');
            
            currentWordSearchWords.forEach(word => {
                const upperWord = word.toUpperCase();
                
                if (selectionUpper === upperWord || reversedSelectionUpper === upperWord) {
                    found = true;
                    if (!foundWords.includes(upperWord)) {
                        foundWords.push(upperWord);
                        highlightedCells.forEach(cell => cell.classList.add('found'));
                        document.getElementById(`word-item-${upperWord}`).classList.add('found-word');
                        searchFeedback.textContent = `Success! You found: ${upperWord}! ‚úÖ`;
                        
                        if (currentWordSearchWords.every(w => foundWords.includes(w.toUpperCase()))) {
                            setTimeout(showRoundSuccess, 1000);
                        }
                    } else {
                        searchFeedback.textContent = `You already found: ${upperWord}!`;
                    }
                }
            });
            
            if (!found) {
                searchFeedback.textContent = `Not a match. Keep searching! ü§î`;
            }
        }
        
        function showRoundSuccess() {
            // A palavra "foundWords.length" n√£o √© √∫til aqui, pois o contador pode ter reiniciado
            searchFeedback.textContent = `Round Complete! You found all ${WORDS_PER_ROUND} words in this puzzle! üèÜ`;
            nextSearchBtn.style.display = 'block';
        }
        
        function nextSearchRound() {
            nextSearchBtn.style.display = 'none';
            currentWordSearchWords = selectRandomWords();
            generateWordSearchGrid();
            renderWordSearch();
        }

        // --- INICIALIZA√á√ÉO ---

        function initGame() {
            // Configura os navegadores
            navBtns.quiz.onclick = () => showScreen('quiz-screen');
            navBtns.memory.onclick = () => showScreen('memory-game-screen');
            navBtns.wordsearch.onclick = () => showScreen('word-search-screen');
            
            // Configura bot√µes de A√ß√£o
            startQuizBtn.onclick = startQuiz;
            memorySetBtn.onclick = nextMemorySet;
            startSearchBtn.onclick = startWordSearch;
            nextSearchBtn.onclick = nextSearchRound;

            // Inicializa Quiz (na primeira tela)
            showScreen('quiz-screen');
            // Inicializa Memory Game (Set 1)
            setupMemoryGame(0); 
            
            // Pr√©-renderiza a grid do Ca√ßa-Palavras com palavras aleat√≥rias
            currentWordSearchWords = shuffleArray(searchableWords).slice(0, WORDS_PER_ROUND);
            generateWordSearchGrid();
            renderWordSearch();
            searchFeedback.textContent = 'Ready to start!';
        }

        document.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>
</html>
